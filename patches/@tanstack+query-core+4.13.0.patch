# generated by patch-package 6.4.14
#
# declared package:
#   @tanstack/query-core: 4.13.0
#
diff --git a/node_modules/@tanstack/query-core/build/lib/queryObserver.esm.js b/node_modules/@tanstack/query-core/build/lib/queryObserver.esm.js
index 7a9d8b4..586f157 100644
--- a/node_modules/@tanstack/query-core/build/lib/queryObserver.esm.js
+++ b/node_modules/@tanstack/query-core/build/lib/queryObserver.esm.js
@@ -21,10 +21,14 @@ class QueryObserver extends Subscribable {
   }
 
   onSubscribe() {
+console.log('QueryObserver.onSubscribe this.listeners', this.listeners)
     if (this.listeners.length === 1) {
       this.currentQuery.addObserver(this);
 
       if (shouldFetchOnMount(this.currentQuery, this.options)) {
+
+console.log('QueryObserver.onSubscribe executeFetch')
+
         this.executeFetch();
       }
 
@@ -58,7 +62,7 @@ class QueryObserver extends Subscribable {
     const prevQuery = this.currentQuery;
     this.options = this.client.defaultQueryOptions(options);
 
-    if (!shallowEqualObjects(prevOptions, this.options)) {
+    if (!shallowEqualObjects(prevOptions, this.options, ["queryKey"])) {
       this.client.getQueryCache().notify({
         type: 'observerOptionsUpdated',
         query: this.currentQuery,
@@ -158,6 +162,10 @@ class QueryObserver extends Subscribable {
   }
 
   executeFetch(fetchOptions) {
+
+// trace
+console.log('QueryObserver.executeFetch', new Error().stack)
+
     // Make sure we reference the latest query as the current one might have been removed
     this.updateQuery(); // Fetch
 
@@ -491,11 +499,29 @@ class QueryObserver extends Subscribable {
 }
 
 function shouldLoadOnMount(query, options) {
+
+console.log('QueryObserver shouldLoadOnMount: options.enabled', (options.enabled), 'fetch', (options.enabled !== false))
+console.log('QueryObserver shouldLoadOnMount: query.state.dataUpdatedAt', (query.state.dataUpdatedAt), 'fetch', (!query.state.dataUpdatedAt))
+console.log(`QueryObserver shouldLoadOnMount: query.state.status'`, query.state.status, 'fetch', (!(query.state.status === 'error' && options.retryOnMount === false)))
+console.log(`QueryObserver shouldLoadOnMount: options.retryOnMount'`, options.retryOnMount)
+
   return options.enabled !== false && !query.state.dataUpdatedAt && !(query.state.status === 'error' && options.retryOnMount === false);
 }
 
 function shouldFetchOnMount(query, options) {
+
+console.log('QueryObserver shouldFetchOnMount: shouldLoadOnMount', shouldLoadOnMount(query, options))
+console.log(`QueryObserver shouldFetchOnMount: query.state.dataUpdatedAt'`, query.state.dataUpdatedAt, 'fetch', (query.state.dataUpdatedAt > 0))
+console.log('QueryObserver shouldFetchOnMount: options.refetchOnMount', options.refetchOnMount)
+console.log('QueryObserver shouldFetchOnMount: shouldFetchOn(query, options, options.refetchOnMount)', shouldFetchOn(query, options, options.refetchOnMount))
+console.log('QueryObserver shouldFetchOnMount', (shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount)))
+
+// this was blocking fetch
+// fixedb by setting
+//      refetchOnMount: true,
+//      refetchOnReconnect: true,
   return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0 && shouldFetchOn(query, options, options.refetchOnMount);
+  //return shouldLoadOnMount(query, options) || query.state.dataUpdatedAt > 0;
 }
 
 function shouldFetchOn(query, options, field) {
diff --git a/node_modules/@tanstack/query-core/build/lib/utils.esm.js b/node_modules/@tanstack/query-core/build/lib/utils.esm.js
index 82754c4..d6ccb3c 100644
--- a/node_modules/@tanstack/query-core/build/lib/utils.esm.js
+++ b/node_modules/@tanstack/query-core/build/lib/utils.esm.js
@@ -227,12 +227,14 @@ function replaceEqualDeep(a, b) {
  * Shallow compare objects. Only works with objects that always have the same properties.
  */
 
-function shallowEqualObjects(a, b) {
+function shallowEqualObjects(a, b, skipKeys = []) {
   if (a && !b || b && !a) {
     return false;
   }
 
   for (const key in a) {
+    // NOTE(milahu): need this to ignore queryKey with Proxy objects in solidjs
+    if (skipKeys && skipKeys.includes(key)) continue
     if (a[key] !== b[key]) {
       return false;
     }
