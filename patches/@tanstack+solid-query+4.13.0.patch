# generated by patch-package 6.4.14
#
# declared package:
#   @tanstack/solid-query: 4.13.0
#
diff --git a/node_modules/@tanstack/solid-query/build/lib/createQueries.esm.js b/node_modules/@tanstack/solid-query/build/lib/createQueries.esm.js
index 7a6544a..e39c9ee 100644
--- a/node_modules/@tanstack/solid-query/build/lib/createQueries.esm.js
+++ b/node_modules/@tanstack/solid-query/build/lib/createQueries.esm.js
@@ -1,6 +1,7 @@
 import { onCleanup, onMount, createComputed } from 'solid-js';
 import { QueriesObserver } from '@tanstack/query-core';
 import { useQueryClient } from './QueryClientProvider.esm.js';
+import { useIsRestoring } from './isRestoring.esm.js';
 import { createStore, unwrap } from 'solid-js/store';
 import { scheduleMicrotask } from './utils.esm.js';
 
@@ -10,13 +11,14 @@ function createQueries(queriesOptions) {
   const queryClient = useQueryClient({
     context: queriesOptions.context
   });
+  const isRestoring = useIsRestoring();
 
   const normalizeOptions = options => {
     const normalizedOptions = { ...options,
       queryKey: options.queryKey == null ? void 0 : options.queryKey()
     };
     const defaultedOptions = queryClient.defaultQueryOptions(normalizedOptions);
-    defaultedOptions._optimisticResults = 'optimistic';
+    defaultedOptions._optimisticResults = isRestoring ? 'isRestoring' : 'optimistic'; // Include callbacks in batch renders
     return defaultedOptions;
   };
 
diff --git a/node_modules/@tanstack/solid-query/build/lib/createQuery.esm.js b/node_modules/@tanstack/solid-query/build/lib/createQuery.esm.js
index 88ded1d..57a5f98 100644
--- a/node_modules/@tanstack/solid-query/build/lib/createQuery.esm.js
+++ b/node_modules/@tanstack/solid-query/build/lib/createQuery.esm.js
@@ -12,7 +12,13 @@ import { createBaseQuery } from './createBaseQuery.esm.js';
 function createQuery(arg1, arg2, arg3) {
   // The parseQuery Args functions helps normalize the arguments into the correct form.
   // Whatever the parameters are, they are normalized into the correct form.
-  const [parsedOptions, setParsedOptions] = createStore(parseQueryArgs(arg1, arg2, arg3)); // Watch for changes in the options and update the parsed options.
+
+  //const [parsedOptions, setParsedOptions] = createStore(parseQueryArgs(arg1, arg2, arg3)); // Watch for changes in the options and update the parsed options.
+
+  const parsedOptionsValue = utils.parseQueryArgs(arg1, arg2, arg3);
+  console.log('createQuery: parsedOptionsValue', parsedOptionsValue)
+  // TODO rename: parsedOptions -> getParsedOptions
+  const [parsedOptions, setParsedOptions] = store.createStore(parsedOptionsValue); // Watch for changes in the options and update the parsed options.
 
   createComputed(() => {
     const newParsedOptions = parseQueryArgs(arg1, arg2, arg3);
diff --git a/node_modules/@tanstack/solid-query/build/lib/createQuery.js b/node_modules/@tanstack/solid-query/build/lib/createQuery.js
index 174cfc5..13c3231 100644
--- a/node_modules/@tanstack/solid-query/build/lib/createQuery.js
+++ b/node_modules/@tanstack/solid-query/build/lib/createQuery.js
@@ -16,7 +16,10 @@ var createBaseQuery = require('./createBaseQuery.js');
 function createQuery(arg1, arg2, arg3) {
   // The parseQuery Args functions helps normalize the arguments into the correct form.
   // Whatever the parameters are, they are normalized into the correct form.
-  const [parsedOptions, setParsedOptions] = store.createStore(utils.parseQueryArgs(arg1, arg2, arg3)); // Watch for changes in the options and update the parsed options.
+  const parsedOptionsValue = utils.parseQueryArgs(arg1, arg2, arg3);
+  console.log('createQuery: parsedOptionsValue', parsedOptionsValue)
+  // TODO rename: parsedOptions -> getParsedOptions
+  const [parsedOptions, setParsedOptions] = store.createStore(parsedOptionsValue); // Watch for changes in the options and update the parsed options.
 
   solidJs.createComputed(() => {
     const newParsedOptions = utils.parseQueryArgs(arg1, arg2, arg3);
diff --git a/node_modules/@tanstack/solid-query/build/lib/createQuery.mjs b/node_modules/@tanstack/solid-query/build/lib/createQuery.mjs
index 7c65883..99d789d 100644
--- a/node_modules/@tanstack/solid-query/build/lib/createQuery.mjs
+++ b/node_modules/@tanstack/solid-query/build/lib/createQuery.mjs
@@ -12,7 +12,13 @@ import { createBaseQuery } from './createBaseQuery.mjs';
 function createQuery(arg1, arg2, arg3) {
   // The parseQuery Args functions helps normalize the arguments into the correct form.
   // Whatever the parameters are, they are normalized into the correct form.
-  const [parsedOptions, setParsedOptions] = createStore(parseQueryArgs(arg1, arg2, arg3)); // Watch for changes in the options and update the parsed options.
+
+  //const [parsedOptions, setParsedOptions] = createStore(parseQueryArgs(arg1, arg2, arg3)); // Watch for changes in the options and update the parsed options.
+
+  const parsedOptionsValue = utils.parseQueryArgs(arg1, arg2, arg3);
+  console.log('createQuery: parsedOptionsValue', parsedOptionsValue)
+  // TODO rename: parsedOptions -> getParsedOptions
+  const [parsedOptions, setParsedOptions] = store.createStore(parsedOptionsValue); // Watch for changes in the options and update the parsed options.
 
   createComputed(() => {
     const newParsedOptions = parseQueryArgs(arg1, arg2, arg3);
diff --git a/node_modules/@tanstack/solid-query/build/solid/QueryClientProvider.jsx b/node_modules/@tanstack/solid-query/build/solid/QueryClientProvider.jsx
index fc7a09a..5ad60c3 100644
--- a/node_modules/@tanstack/solid-query/build/solid/QueryClientProvider.jsx
+++ b/node_modules/@tanstack/solid-query/build/solid/QueryClientProvider.jsx
@@ -9,19 +9,44 @@ const QueryClientSharingContext = createContext(false);
 // all use the same **instance** of context, regardless
 // of module scoping.
 function getQueryClientContext(context, contextSharing) {
+
     if (context) {
+  //console.log(`QueryClientProvider getQueryClientContext: context from arg`)
         return context;
     }
+
+  //console.log(`QueryClientProvider getQueryClientContext: contextSharing`, contextSharing) // false
     if (contextSharing && typeof window !== 'undefined') {
         if (!window.SolidQueryClientContext) {
+      //console.log(`QueryClientProvider getQueryClientContext: set window.SolidQueryClientContext`)
             window.SolidQueryClientContext = defaultContext;
         }
+
+    //console.log(`QueryClientProvider getQueryClientContext: return window.SolidQueryClientContext`)
         return window.SolidQueryClientContext;
     }
+
+  //console.log(`QueryClientProvider getQueryClientContext: return defaultContext`)
     return defaultContext;
 }
+
+
+
 export const useQueryClient = ({ context } = {}) => {
-    const queryClient = useContext(getQueryClientContext(context, useContext(QueryClientSharingContext)));
+
+  // FIXME
+  //const queryClient = useContext(getQueryClientContext(context, useContext(QueryClientSharingContext)));
+
+  //console.log(`useQueryClient context`, context)
+
+  const u = useContext(QueryClientSharingContext)
+  //console.log(`useQueryClient useContext?`, u)
+  const c = getQueryClientContext(context, u)
+  //console.log(`useQueryClient queryClientContext`, c)
+  const queryClient = useContext(c);
+  // FIXME queryClient === undefined
+  //console.log(`useQueryClient queryClient`, queryClient)
+
     if (!queryClient) {
         throw new Error('No QueryClient set, use QueryClientProvider to set one');
     }
diff --git a/node_modules/@tanstack/solid-query/build/solid/createBaseQuery.js b/node_modules/@tanstack/solid-query/build/solid/createBaseQuery.js
index 6665b9c..e287996 100644
--- a/node_modules/@tanstack/solid-query/build/solid/createBaseQuery.js
+++ b/node_modules/@tanstack/solid-query/build/solid/createBaseQuery.js
@@ -1,19 +1,64 @@
 import { useQueryClient } from './QueryClientProvider';
-import { onMount, onCleanup, createComputed, createResource, on, batch, } from 'solid-js';
+import { useIsRestoring } from './isRestoring';
+import { onMount, onCleanup, createComputed, createResource, createEffect, on, batch, } from 'solid-js';
 import { createStore, unwrap } from 'solid-js/store';
 import { shouldThrowError } from './utils';
+//import { notifyManager } from '@tanstack/query-core';
+
+// workaround ...
+// TODO more generic
+function cleanupQueryKeyProp(query) {
+    //return // debug
+
+    // Proxy -> Array
+    query.queryKey = [ ...query.queryKey ]
+    // Proxy -> Object
+    query.queryKey[1] = { ...query.queryKey[1] }
+}
+
 // Base Query Function that is used to create the query.
 export function createBaseQuery(options, Observer) {
     const queryClient = useQueryClient({ context: options.context });
+    const isRestoring = useIsRestoring();
+
+  //const [count, { increment, decrement }] = useCounter();
+
+
+    console.log('@tanstack/solid-query createBaseQuery createBaseQuery isRestoring', isRestoring)
+    console.log('@tanstack/solid-query createBaseQuery createBaseQuery isRestoring()', isRestoring())
     const emptyData = Symbol('empty');
+    // TODO(milahu): cleanup options?
+    // TODO(milahu): remove solidjs Proxy objects from options?
+    // TODO(milahu): Observer?
+    // NOTE(milahu): options is a Proxy
+    // NOTE(milahu): defaultedOptions is an object
+    // NOTE(milahu): defaultedOptions.queryKey is a Proxy
     const defaultedOptions = queryClient.defaultQueryOptions(options);
-    defaultedOptions._optimisticResults = 'optimistic';
+    defaultedOptions._optimisticResults = isRestoring() ? 'isRestoring' : 'optimistic'; // Include callbacks in batch renders
+    console.log('@tanstack/solid-query createBaseQuery init observer: options', options)
+
+    cleanupQueryKeyProp(defaultedOptions)
+    console.log('@tanstack/solid-query createBaseQuery init observer: defaultedOptions', defaultedOptions)
+
+    /* react
+    const [observer] = React.useState(() => new Observer(queryClient, defaultedOptions));
+    const result = observer.getOptimisticResult(defaultedOptions);
+    */
+
     const observer = new Observer(queryClient, defaultedOptions);
+
+    // get the initial result
+    // react: result
+    // solid: state
     const [state, setState] = createStore(
     // @ts-ignore
     observer.getOptimisticResult(defaultedOptions));
+
     const [dataResource, { refetch, mutate }] = createResource(() => {
         return new Promise((resolve) => {
+            console.log('dataResource Promise: isRestoring', isRestoring())
+            //if (!(state.isFetching && state.isLoading && !isRestoring())) { // wrong?
+            // wrong place to check isRestoring
             if (!(state.isFetching && state.isLoading)) {
                 if (unwrap(state.data) === emptyData) {
                     resolve(undefined);
@@ -27,39 +72,46 @@ export function createBaseQuery(options, Observer) {
         refetch();
     });
     let taskQueue = [];
-    const unsubscribe = observer.subscribe((result) => {
-        taskQueue.push(() => {
-            batch(() => {
-                const unwrappedResult = { ...unwrap(result) };
-                if (unwrappedResult.data === undefined) {
-                    // This is a hack to prevent Solid
-                    // from deleting the data property when it is `undefined`
-                    // ref: https://www.solidjs.com/docs/latest/api#updating-stores
-                    // @ts-ignore
-                    unwrappedResult.data = emptyData;
-                }
-                setState(unwrap(unwrappedResult));
-                mutate(() => unwrap(result.data));
-                refetch();
-            });
-        });
-        queueMicrotask(() => {
-            const taskToRun = taskQueue.pop();
-            if (taskToRun) {
-                taskToRun();
-            }
-            taskQueue = [];
-        });
-    });
+
+
+
+/* TODO translate react to solid
+// https://github.com/TanStack/query/blob/main/packages/react-query/src/useBaseQuery.ts
+
+  useSyncExternalStore(
+    React.useCallback(
+      (onStoreChange) =>
+        isRestoring
+          ? () => undefined
+          : observer.subscribe(notifyManager.batchCalls(onStoreChange)),
+      [observer, isRestoring],
+    ),
+    () => observer.getCurrentResult(),
+    () => observer.getCurrentResult(),
+  )
+*/
+    let unsubscribe = () => undefined;
+
     onCleanup(() => unsubscribe());
     onMount(() => {
+        // TODO(milahu): cleanup options?
+        // redundant?
+        //cleanupQueryKeyProp(defaultedOptions)
+        console.log('@tanstack/solid-query createBaseQuery onMount: defaultedOptions', defaultedOptions)
         observer.setOptions(defaultedOptions, { listeners: false });
     });
+    // NOTE(milahu): this is reactive to options
     createComputed(() => {
+        console.log('@tanstack/solid-query createBaseQuery createComputed(options): isRestoring()', isRestoring())
         const newDefaultedOptions = queryClient.defaultQueryOptions(options);
+        newDefaultedOptions._optimisticResults = isRestoring() ? 'isRestoring' : 'optimistic'; // Include callbacks in batch renders
+        // TODO(milahu): cleanup options?
+        cleanupQueryKeyProp(newDefaultedOptions)
+        console.log('@tanstack/solid-query createBaseQuery createComputed(options): newDefaultedOptions', newDefaultedOptions)
         observer.setOptions(newDefaultedOptions);
     });
     createComputed(on(() => state.status, () => {
+        console.log('@tanstack/solid-query createBaseQuery createComputed(state.status)')
         if (state.isError &&
             !state.isFetching &&
             shouldThrowError(observer.options.useErrorBoundary, [
@@ -69,6 +121,104 @@ export function createBaseQuery(options, Observer) {
             throw state.error;
         }
     }));
+    /* TypeError: Cannot read properties of undefined (reading 'currentResult')
+    createComputed(on(observer.getCurrentResult, () => {
+        console.log(`@tanstack/solid-query createBaseQuery createComputed observer.getCurrentResult()`, observer.getCurrentResult())
+    }));
+    */
+
+
+
+    //createComputed(on(isRestoring, () => {
+    createComputed(() => {
+
+        // debug
+        console.log('@tanstack/solid-query createBaseQuery createComputed(isRestoring): isRestoring()', isRestoring())
+        if (isRestoring()) {
+            // TODO ...?
+            // called by ...?
+            // @tanstack/query-core/build/lib/query.esm.js
+            // observer.onQueryUpdate(action);
+            /* no. this will refetch = cache miss
+            observer.subscribe((result) => {
+                console.log('@tanstack/solid-query createBaseQuery createComputed(isRestoring): observer.subscribe', new Error().stack)
+                console.log('@tanstack/solid-query createBaseQuery createComputed(isRestoring): observer.subscribe result', result)
+            })
+            */
+            return;
+        }
+
+        /*
+        console.log('@tanstack/solid-query createBaseQuery createComputed(isRestoring): observer.setOptions')
+        const newDefaultedOptions = queryClient.defaultQueryOptions(options);
+        newDefaultedOptions._optimisticResults = isRestoring() ? 'isRestoring' : 'optimistic'; // Include callbacks in batch renders
+        // TODO(milahu): cleanup options?
+        cleanupQueryKeyProp(newDefaultedOptions)
+        console.log('@tanstack/solid-query createBaseQuery createComputed(isRestoring): newDefaultedOptions', newDefaultedOptions)
+        observer.setOptions(newDefaultedOptions);
+        */
+
+
+
+
+        console.log('@tanstack/solid-query createBaseQuery createComputed(isRestoring): observer.getOptimisticResult ...')
+        console.log('@tanstack/solid-query createBaseQuery createComputed(isRestoring): observer.getOptimisticResult', observer.getOptimisticResult(defaultedOptions))
+
+        // react-query/src/useBaseQuery.ts calls observer.getCurrentResult
+        console.log('@tanstack/solid-query createBaseQuery createComputed(isRestoring): observer.getCurrentResult ...')
+        console.log('@tanstack/solid-query createBaseQuery createComputed(isRestoring): observer.getCurrentResult', observer.getCurrentResult())
+
+        console.log('@tanstack/solid-query createBaseQuery createComputed(isRestoring): isRestoring=false -> calling observer.subscribe')
+
+        // debug
+        console.log('@tanstack/solid-query createBaseQuery createComputed(isRestoring): isRestoring=false -> calling observer.subscribe')
+
+        // FIXME this does not update query.status
+        // result is in cache but is not loaded
+
+        // result is the actual fetch-result
+        //unsubscribe = observer.subscribe((result) => {
+        const handleResult = (result) => {
+            console.log('@tanstack/solid-query createBaseQuery createComputed(isRestoring) observer.subscribe: result', result)
+            taskQueue.push(() => {
+                batch(() => {
+                    console.log('@tanstack/solid-query createBaseQuery createComputed(isRestoring) observer.subscribe: batch')
+                    const unwrappedResult = { ...unwrap(result) };
+                    if (unwrappedResult.data === undefined) {
+                        // This is a hack to prevent Solid
+                        // from deleting the data property when it is `undefined`
+                        // ref: https://www.solidjs.com/docs/latest/api#updating-stores
+                        // @ts-ignore
+                        unwrappedResult.data = emptyData;
+                    }
+                    console.log('@tanstack/solid-query createBaseQuery createComputed(isRestoring) observer.subscribe: setState')
+                    // TODO(milahu): why unwrap again?
+                    setState(unwrap(unwrappedResult));
+                    console.log('@tanstack/solid-query createBaseQuery createComputed(isRestoring) observer.subscribe: mutate')
+                    mutate(() => unwrap(result.data));
+                    console.log('@tanstack/solid-query createBaseQuery createComputed(isRestoring) observer.subscribe: refetch')
+                    refetch();
+                });
+            });
+            queueMicrotask(() => {
+                const taskToRun = taskQueue.pop();
+                if (taskToRun) {
+                    taskToRun();
+                }
+                taskQueue = [];
+            });
+        };
+
+        // result was restored from cache -> update result
+        handleResult(observer.getCurrentResult());
+
+        // listen for future results
+        observer.subscribe(handleResult);
+    });
+//    }));
+
+
+
     const handler = {
         get(target, prop) {
             if (prop === 'data') {
diff --git a/node_modules/@tanstack/solid-query/build/solid/createQueries.js b/node_modules/@tanstack/solid-query/build/solid/createQueries.js
index 6d52220..ea7834c 100644
--- a/node_modules/@tanstack/solid-query/build/solid/createQueries.js
+++ b/node_modules/@tanstack/solid-query/build/solid/createQueries.js
@@ -1,14 +1,16 @@
 import { createComputed, onCleanup, onMount } from 'solid-js';
 import { QueriesObserver } from '@tanstack/query-core';
 import { useQueryClient } from './QueryClientProvider';
+import { useIsRestoring } from './isRestoring';
 import { createStore, unwrap } from 'solid-js/store';
 import { scheduleMicrotask } from './utils';
 export function createQueries(queriesOptions) {
     const queryClient = useQueryClient({ context: queriesOptions.context });
+    const isRestoring = useIsRestoring();
     const normalizeOptions = (options) => {
         const normalizedOptions = { ...options, queryKey: options.queryKey?.() };
         const defaultedOptions = queryClient.defaultQueryOptions(normalizedOptions);
-        defaultedOptions._optimisticResults = 'optimistic';
+        defaultedOptions._optimisticResults = isRestoring ? 'isRestoring' : 'optimistic'; // Include callbacks in batch renders
         return defaultedOptions;
     };
     const defaultedQueries = queriesOptions.queries.map((options) => normalizeOptions(options));
diff --git a/node_modules/@tanstack/solid-query/build/solid/createQuery.js b/node_modules/@tanstack/solid-query/build/solid/createQuery.js
index 7219b1e..8592864 100644
--- a/node_modules/@tanstack/solid-query/build/solid/createQuery.js
+++ b/node_modules/@tanstack/solid-query/build/solid/createQuery.js
@@ -6,8 +6,15 @@ import { createBaseQuery } from './createBaseQuery';
 export function createQuery(arg1, arg2, arg3) {
     // The parseQuery Args functions helps normalize the arguments into the correct form.
     // Whatever the parameters are, they are normalized into the correct form.
-    const [parsedOptions, setParsedOptions] = createStore(parseQueryArgs(arg1, arg2, arg3));
+    
+    //const [parsedOptions, setParsedOptions] = createStore(parseQueryArgs(arg1, arg2, arg3));
     // Watch for changes in the options and update the parsed options.
+
+  const parsedOptionsValue = parseQueryArgs(arg1, arg2, arg3);
+  console.log('createQuery: parsedOptionsValue', parsedOptionsValue)
+  // note: strictly speaking: parsedOptions -> getParsedOptions
+  const [parsedOptions, setParsedOptions] = createStore(parsedOptionsValue); // Watch for changes in the options and update the parsed options.
+
     createComputed(() => {
         const newParsedOptions = parseQueryArgs(arg1, arg2, arg3);
         setParsedOptions(newParsedOptions);
diff --git a/node_modules/@tanstack/solid-query/build/solid/index.js b/node_modules/@tanstack/solid-query/build/solid/index.js
index 04c68ec..4937f6f 100644
--- a/node_modules/@tanstack/solid-query/build/solid/index.js
+++ b/node_modules/@tanstack/solid-query/build/solid/index.js
@@ -10,3 +10,4 @@ export { useIsMutating } from './useIsMutating';
 export { createMutation } from './createMutation';
 export { createInfiniteQuery } from './createInfiniteQuery';
 export { createQueries } from './createQueries';
+export { IsRestoringProvider, IsRestoringContext, useIsRestoring } from './isRestoring';
diff --git a/node_modules/@tanstack/solid-query/build/solid/isRestoring.js b/node_modules/@tanstack/solid-query/build/solid/isRestoring.js
new file mode 100644
index 0000000..bc2889c
--- /dev/null
+++ b/node_modules/@tanstack/solid-query/build/solid/isRestoring.js
@@ -0,0 +1,26 @@
+/*
+
+pause all queries until persistent cache is restored
+
+based on
+node_modules/@tanstack/react-query/build/lib/isRestoring.esm.js
+
+used in
+node_modules/@tanstack/react-query/build/lib/useBaseQuery.esm.js
+node_modules/@tanstack/react-query/build/lib/useQueries.esm.js
+
+*/
+
+import { createContext, useContext } from 'solid-js';
+import { createSignal } from 'solid-js';
+
+//const IsRestoringContext = createContext(false); // default value: isRestoring = false
+
+// NOTE(milahu): overhead? this makes the call-site simpler
+const [isRestoring, _setIsRestoring] = createSignal(false) // default value: isRestoring = false
+const IsRestoringContext = createContext(isRestoring);
+
+const useIsRestoring = () => useContext(IsRestoringContext);
+const IsRestoringProvider = IsRestoringContext.Provider;
+
+export { IsRestoringContext, IsRestoringProvider, useIsRestoring }
diff --git a/node_modules/@tanstack/solid-query/todo.md b/node_modules/@tanstack/solid-query/todo.md
new file mode 100644
index 0000000..8b48077
--- /dev/null
+++ b/node_modules/@tanstack/solid-query/todo.md
@@ -0,0 +1,20 @@
+# todo
+
+## sync API names
+
+https://github.com/TanStack/query/pull/4211#issuecomment-1288123283
+
+| react-query | solid-query |
+| --- | --- |
+| [useQuery][1] | createQuery
+| useBaseQuery | createBaseQuery |
+| useQueries | createQueries |
+| useQueryClient | useQueryClient |
+| useHydrate | (missing) |
+| useQueryErrorResetBoundary | (missing) |
+| useIsFetching | useIsFetching |
+| useMutation | createMutation |
+| useInfiniteQuery | createInfiniteQuery |
+| useIsRestoring | useIsRestoring (new) |
+
+[1]: https://tanstack.com/query/v4/docs/reference/useQuery
